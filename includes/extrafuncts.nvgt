bool string_file_encrypt(string input_file, string output_file, string key)
{
    file f;
    if (!f.open(input_file, "rb")) return false;
    string text = f.read();
    f.close();
    text = string_encrypt(text, key);
    if (text == "") return false;
    if (!f.open(output_file, "wb")) return false;
    f.write(text);
    f.close();
    return true;
}
bool string_file_decrypt(const string& input_file, const string& output_file, const string& encryption_key)
{
file input;
if (!input.open(input_file, "rb"))
return false;
string encrypted_content = input.read();
input.close();
string decrypted_content = string_decrypt(encrypted_content, encryption_key);
file output;
if (!output.open(output_file, "wb"))
return false;
output.write(decrypted_content);
output.close();
return true;
}
bool string_starts_with(const string& in str, const string& in start)
{
if (str.length()>=start.length())
{
return (str.substr(0, start.length()) == start);
}
return false;
}
bool string_ends_with(const string& in str,const string& in ending)
{
if (str.length()>=ending.length())
{
return (str.substr(str.length()-ending.length())==ending);
}
return false;
}
double clamp(double value, double min, double max)
{
value=value<min? min:value;
value=value>max? max:value;
return value;
}
double min(double a, double b)
{
return (a < b) ? a : b;
}
double max(double a, double b)
{
return (a > b) ? a : b;
}
string file_encrypt(const string& encrypted_content, const string& encryption_key)
{
return string_encrypt(encrypted_content, encryption_key);
}
string file_decrypt(const string& encrypted_content, const string& encryption_key)
{
return string_decrypt(encrypted_content, encryption_key);
}
string generate_token(int token_length)
{
string token_sims="1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
string final_token;
for(uint i=0; i<token_length; i++)
{
final_token+=token_sims[random(0, token_sims.length()-1)];
}
return final_token;
}
string trim(const string&in str)
{
string result = str;
while (result.length() > 0 && (string_left(result, 1) == " " || string_left(result, 1) == "\n" || string_left(result, 1) == "\r"))
{
result = string_trim_left(result, 1);
}
while (result.length() > 0 && (string_right(result, 1) == " " || string_right(result, 1) == "\n" || string_right(result, 1) == "\r"))
{
result = string_trim_right(result, 1);
}
return result;
}
void create_subfolders(string filepath)
{
    string[] parts = string_split(filepath, "/", true);
    if (parts.length() <= 1) return;
    parts.resize(parts.length() - 1);
    string path;
    for (uint i = 0; i < parts.length(); i++)
    {
        path += parts[i];
        if (i < parts.length() - 1) path += "/";
        if (!directory_exists(path)) directory_create(path);
    }
}
void extract_file(pack@ pf, const string&in filename, const string&in outfile)
{
    uint size = pf.get_file_size(filename);
    string content = pf.read_file(filename, 0, size);
    if (use_key)
    {
        string decrypted;
        if (strpack)
            decrypted = string_decrypt(content, decrypt_key);
        else
            decrypted = file_decrypt(content, decrypt_key);
        if (decrypted != "")
            content = decrypted;
    }
    file f;
    f.open(outfile, "wb");
    f.write(content);
    f.close();
}
void find_stuff(string base, string path)
{
    string[] dirs = find_directories(path + "\\*");
    string[] files = find_files(path + "\\*.*");
    for (uint i = 0; i < files.length(); i++)
        file_list.insert_last(path + "/" + files[i]);
    for (uint j = 0; j < dirs.length(); j++)
        find_stuff(base, path + "/" + dirs[j]);
}
