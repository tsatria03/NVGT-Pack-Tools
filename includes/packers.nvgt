void create_pack()
{
    if (!directory_exists("data"))
        directory_create("data");
    if (COMMAND_LINE == "/s")
        silent = true;
    if (file_exists("data/pack.pk"))
    {
        int use_saved = (silent ? 1 : question("File was found.", "Would you like to use the existing saved data?"));
        if (use_saved == 1)
            cont = false;
wait(500);
    }
    if (cont)
    {
        filename = vd.input_box("Pack Creator", "Enter the name of the pack file to create");
        if (filename == "")
{
alert("Error", "You may not create an empty pack!");
maintool();
}
        foldername = vd.input_box("Pack Creator", "Enter the path containing files to pack");
        if (foldername == "") maintool();
        int answer = question("Pack Creator", "Would you like these files to be encrypted?");
        if (answer == 1)
        {
            encrypt = true;
            encryption_key = vd.input_box("Pack Creator", "Enter the encryption key for this pack.");
            if (encryption_key == "") maintool();
            if (string_left(encryption_key, 6) == "file::")
            {
                if (!f.open(string_trim_left(encryption_key, 6), "rb"))
                {
                    alert("Error", "Failed to open key file.");
                    maintool();
                }
                encryption_key = f.read();
                f.close();
            }
            if (string_left(encryption_key, 5) == "str::")
            {
                strpack = true;
                encryption_key = string_trim_left(encryption_key, 5);
            }
            if (string_left(encryption_key, 5) == "hex::")
                encryption_key = hex_to_string(string_trim_left(encryption_key, 5));
            if (string_left(encryption_key, 10) == "str::hex::")
            {
                strpack = true;
                encryption_key = hex_to_string(string_trim_left(encryption_key, 10));
            }
        }
        f.open("data/pack.pk", "wb");
        f.write(filename + "{:}" + foldername + "{:}" + (encrypt ? "1{:}" + encryption_key : "0"));
        f.close();
    }
    else
    {
        f.open("data/pack.pk", "rb");
        string[] data = string_split(f.read(), "{:}", true);
        f.close();
        filename = data[0];
        foldername = data[1];
        encrypt = (string_to_number(data[2]) == 1);
        if (encrypt) encryption_key = data[3];
    }
    if (!directory_exists(foldername))
    {
        if (!silent) alert("Error", "Folder does not exist!");
        maintool();
    }
    if (!pfile.open(filename, PACK_OPEN_MODE_CREATE))
    {
        alert("Error", "Failed to create pack file!");
        maintool();
    }
    find_stuff(foldername, foldername);
    if (!silent)
        alert("Pack Creator", "There are " + file_list.length() + " files in the pack. Press OK to start packing!");
    show_window("Packing...");
    wait(5);
    int percent = -1;
for (uint i = 0; i < file_list.length(); i++)
{
    double progress = (double(i) / double(file_list.length())) * 100.0;
    int rounded = int(progress);
    if (rounded != percent)
    {
        percent = rounded;
        beep_percentage(percent);
    }
    string relative = string_replace(file_list[i], foldername + "/", "", true);
        pfile.add_file(file_list[i], relative);
    }
    pfile.close();
    if (!silent) alert("Success!", "Files were added successfully!");
    maintool();
}
void extract_pack()
{
    filename = vd.input_box("Pack Extractor", "Enter the name of the pack file to extract");
    if (filename == "")
    {
        alert("Error", "You may not extract an empty pack!");
        maintool();
    }
    decrypt_key = vd.input_box("Pack Extractor", "Enter the decryption key for this pack. Leave blank for no decryption key.");
    if (get_last_error() == -12) maintool();
    if (decrypt_key != "")
    {
        use_key = true;
        if (string_left(decrypt_key, 6) == "file::")
        {
            if (!temp.open(string_trim_left(decrypt_key, 6), "rb"))
            {
                alert("Error", "Failed to open key file.");
                maintool();
            }
            decrypt_key = temp.read();
            temp.close();
        }
        if (string_left(decrypt_key, 5) == "str::")
        {
            strpack = true;
            decrypt_key = string_trim_left(decrypt_key, 5);
        }
        if (string_left(decrypt_key, 5) == "hex::")
        {
            decrypt_key = hex_to_string(string_trim_left(decrypt_key, 5));
        }
        if (string_left(decrypt_key, 10) == "str::hex::")
        {
            strpack = true;
            decrypt_key = hex_to_string(string_trim_left(decrypt_key, 10));
        }
    }
    end = vd.input_box("Pack Extractor", "Enter anything you want added to the end of the filenames, such as .ogg or .wav.");
    if (get_last_error() == -12) maintool();
    if (!pfile.open(filename, PACK_OPEN_MODE_READ))
    {
        alert("Error", "Could not open the specified pack file.");
        maintool();
    }
    contents = pfile.list_files();
    if (contents.length() == 0)
    {
        alert("Error", "No files found in this pack.");
        maintool();
    }
    alert("Get Ready", contents.length() + " files are about to be extracted!");
    if (!directory_exists("packs"))
        directory_create("packs");
    string base_dir = "packs/" + filename;
    if (!directory_exists(base_dir))
        directory_create(base_dir);
    show_window("Extracting...");
    wait(5);
    double prev_percent = -1;
    for (uint i = 0; i < contents.length(); i++)
    {
        double percent = ((i + 1.0) / contents.length()) * 100.0;
        percent = round(percent, 0);
        if (percent != prev_percent)
        {
            beep_percentage(int(percent));
            prev_percent = percent;
        }
        string relative_path = contents[i];
        string output_path = base_dir + "/" + relative_path + end;
        create_subfolders(output_path);
        extract_file(pfile, relative_path, output_path);
    }
    pfile.close();
    alert("Success", "Extraction completed. " + contents.length() + " files have been extracted to " + base_dir);
}
void generate_pack_key()
{
    create_menu(m);
    m.add_item("Letters only");
    m.add_item("Letters and Numbers");
    m.add_item("Letters and Symbols");
    m.add_item("Letters, Numbers and Symbols");
    m.add_item("Numbers only");
    m.add_item("Numbers and Symbols");
    m.add_item("Symbols only");
    m.add_item("Go back");
    int choice = m.run("Pack key generator menu. Choose a character set you'd like to use.");
    if (choice == 0 || choice == 8) // Escape or "Go back"
    {
        maintool();
    }
    int mode = token_gen_flag_characters;
    if (choice == 1)
        mode = token_gen_flag_characters;
    else if (choice == 2)
        mode = token_gen_flag_characters_numbers;
    else if (choice == 3)
        mode = token_gen_flag_characters_symbols;
    else if (choice == 4)
        mode = token_gen_flag_all;
    else if (choice == 5)
        mode = token_gen_flag_numbers;
    else if (choice == 6)
        mode = token_gen_flag_numbers_symbols;
    else if (choice == 7)
        mode = token_gen_flag_symbols;
    string length_str = vd.input_box("Pack Key Generator", "Enter the encryption key length.", "10");
    if (length_str == "")
    {
        alert("Error", "Invalid key length entered!");
        maintool();
    }
    int length = string_to_number(length_str);
    if (length < 10)
    {
        alert("Error", "Invalid key length entered!");
        maintool();
    }
    string key = generate_token(length, mode);
    clipboard_copy_text(key);
    alert("Pack Key Generator", "The key has been generated and copied to your clipboard!");
    maintool();
}
void list_pack()
{
    string filename = vd.input_box("Pack Lister", "Enter the path/name to a pack file, such as sounds.dat");
    if (filename == "")
    {
        alert("Error", "You may not list an empty pack!");
        maintool();
    }
    bool success = obj.open(filename);
    if (!success)
    {
        alert("Error", "Either this file does not exist or it is not a valid pack file.");
        maintool();
    }
    string outname = vd.input_box("Output Filename", "Enter the name of the file to write the list to. Leave blank to use soundslist.txt.");
    if (outname == "")
        outname = "soundslist.txt";
    string final_list;
    string[] list = obj.list_files();
    for (uint i = 0; i < list.length(); i++)
    {
        final_list += list[i] + "\r\n";
    }
    final_list += "Total files: " + list.length() + "\r\n";
    file slist;
    if (!slist.open(outname, "w"))
    {
        alert("Error", "Unable to write to the specified file!");
        maintool();
    }
    slist.write(final_list);
    slist.close();
    alert("Complete!", "The pack list has been written to " + outname + ".");
}
void view_pack()
{
    string filename = vd.input_box("Pack Viewer", "Enter the name of the pack file to view information from.");
    if (filename == "")
    {
        alert("Error", "You may not view an empty pack!");
        maintool();
    }
    if (!pfile.open(filename, PACK_OPEN_MODE_READ))
    {
        alert("Error", "Could not open this pack file.");
        maintool();
    }
    string[] files = pfile.list_files();
    if (files.length() == 0)
    {
        alert("Error", "No files found in this pack.");
        pfile.close();
        maintool();
    }
    uint64 total_size = 0;
    for (uint i = 0; i < files.length(); i++)
    {
        total_size += pfile.get_file_size(files[i]);
    }
    pfile.close();
info_box("Pack Information", "Pack details", "Pack name: " + filename + "\r\n" + "Total packed files: " + string(files.length()) + "\r\n" + "Total packed size: " + string(total_size) + " bytes\r\n" + "Pack encription: unknown." + "\r\n", MESSAGE_BOX_INFORMATION);
}
